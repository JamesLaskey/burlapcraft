package com.kcaluru.burlapbot.actions;

import java.util.ArrayList;
import java.util.List;

import com.kcaluru.burlapbot.domaingenerator.DungeonWorldDomain;
import com.kcaluru.burlapbot.helpers.NameSpace;

import burlap.oomdp.core.Domain;
import burlap.oomdp.core.ObjectInstance;
import burlap.oomdp.core.State;
import burlap.oomdp.core.TransitionProbability;
import burlap.oomdp.singleagent.Action;

public class MovementAction extends Action {

	/**
	 * Probabilities of the actual direction the agent will go
	 * 0: south, 1: west, 2: north, 3: east 
	 */
	protected double [] directionProbs = new double[4];
	
	public MovementAction(String actionName, Domain domain, int direction, int [][] movementMap) {
		super(actionName, domain, "");
		for(int i = 0; i < 4; i++) {
			if (i == direction) {
				directionProbs[i] = 1.0;
			}
			else {
				directionProbs[i] = 0;
			}
		}
	}
	@Override
	protected State performActionHelper(State s, String[] params) {
		ObjectInstance agent = s.getFirstObjectOfClass(NameSpace.CLASSAGENT);
		int curX = agent.getDiscValForAttribute(NameSpace.ATX);
		int curZ = agent.getDiscValForAttribute(NameSpace.ATZ);
		
		//sample directon with random roll
		double r = Math.random();
		double sumProb = 0.;
		int dir = 0;
		for(int i = 0; i < this.directionProbs.length; i++){
			sumProb += this.directionProbs[i];
			if(r < sumProb){
				dir = i;
				break; //found direction
			}
		}
		
		//get resulting position
		int [] newPos = this.moveResult(curX, curZ, dir, movementMap);
		
		//set the new position
		agent.setValue(NameSpace.ATX, newPos[0]);
		agent.setValue(NameSpace.ATY, 1);
		agent.setValue(NameSpace.ATZ, newPos[1]);
		
		//return the state we just modified
		return s;
	}
	
	protected int [] moveResult(int curX, int curZ, int direction) {
		int xdelta = 0;
		int zdelta = 0;
		if(direction == 0){
			zdelta = 1;
		}
		else if(direction == 1){
			xdelta = -1;
		}
		else if(direction == 2){
			zdelta = -1;
		}
		else{
			xdelta = 1;
		}
		
		int nx = curX + xdelta;
		int nz = curZ + zdelta;
		
		int length = movementMap.length;
		int width = movementMap[0].length;
		
		//make sure new position is valid (not a wall or out of bounds)
		if(nx < 0 || nx >= length || nz < 0 || nz >= width ||  
			DungeonWorldDomain.this.movementMap[nx][nz] >= 1){
			nx = curX;
			nz = curZ;
		}
			
		
		return new int[]{nx,nz};
	}
	
	@Override
	public List<TransitionProbability> getTransitions(State s, String [] params){
		
		//get agent and current position
		ObjectInstance agent = s.getFirstObjectOfClass(NameSpace.CLASSAGENT);
		int curX = agent.getDiscValForAttribute(NameSpace.ATX);
		int curZ = agent.getDiscValForAttribute(NameSpace.ATZ);
		
		List<TransitionProbability> tps = new ArrayList<TransitionProbability>(4);
		TransitionProbability noChangeTransition = null;
		for(int i = 0; i < this.directionProbs.length; i++){
			int [] newPos = this.moveResult(curX, curZ, i);
			if(newPos[0] != curX || newPos[1] != curZ) {
				//new possible outcome
				State ns = s.copy();
				ObjectInstance nagent = ns.getFirstObjectOfClass(NameSpace.CLASSAGENT);
				nagent.setValue(NameSpace.ATX, newPos[0]);
				nagent.setValue(NameSpace.ATZ, newPos[1]);
				
				//create transition probability object and add to our list of outcomes
				tps.add(new TransitionProbability(ns, this.directionProbs[i]));
			}
			else{
				//this direction didn't lead anywhere new
				//if there are existing possible directions that wouldn't lead anywhere, 
				//aggregate with them
				if(noChangeTransition != null){
					noChangeTransition.p += this.directionProbs[i];
				}
				else{
					//otherwise create this new state outcome
					noChangeTransition = new TransitionProbability(s.copy(), this.directionProbs[i]);
					tps.add(noChangeTransition);
				}
			}
		}
		
		
		return tps;
	}
	
}

}
